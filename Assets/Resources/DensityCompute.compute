#pragma kernel Density
#pragma enable_d3d11_debug_symbols
#include "Noise.hlsl"
//Noise Params
StructuredBuffer<float3> _offsets;
float _octaves;
float _lacunarity;
float _persistence;
float _noiseScale;
float _noiseWeight;
float _floorOffset;
float _weightMultiplier;
bool _closeEdges;
float _hardFloor;
float _hardFloorWeight;
float4 _params;

//World Params
RWStructuredBuffer<float4> _points;
float _numPointsPerAxis;
float3 _boundsSize;
float3 _center;
float3 _offset;
float3 _spacing;
float3 _worldSize;


// Landscape 

// Mountain
float _mountainous;

int indexFromCoord(uint x, uint y, uint z) {
	return z * (int)_numPointsPerAxis * (int)_numPointsPerAxis + y * (int)_numPointsPerAxis + x;
}

[numthreads(8, 8, 8)]
void Density(int3 id: SV_DispatchThreadID)
{
	const float PI = 3.14159265358979323846;
	if (id.x >= (int)_numPointsPerAxis || id.y >= (int)_numPointsPerAxis || id.z >= (int)_numPointsPerAxis)
		return;

	float3 pos = _center + id * _spacing - _boundsSize / 2;
	float offsetNoise = 0;
	float noise = 0;
	
	//float frequency = _noiseScale / 100.0;
	//float amplitude = 1.0;
	//float weight = 1.0f;
	//float warp = snoise(pos * 0.009f);
	//warp *= 4.0f;
	//for (int j = 0; j <(int) _octaves; j++)
	//{
	//	float n = snoise((pos + offsetNoise) * frequency + _offsets[j] + _offset);
	//	float v = 1 - abs(n);
	//	v = v*v;
	//	v *= weight;
	//	weight = max(min(v * _weightMultiplier, 1), 0);
	//	noise += v * amplitude;
	//	amplitude *= _persistence;
	//	frequency *= _lacunarity;
	//}

	////float mountain = _params.y * sin(PI * pos.y/ (float)_boundsSize.y);
	//float finalVal = -(pos.y + _floorOffset) + noise * _noiseWeight +
	//	(sin(2.0f * PI * pos.z/_mountainous) + sin(2.0f * PI * pos.x / _mountainous)) * _params.y;
	//
	//
	///*finalVal = noise * _noiseWeight;*/	
	//finalVal += saturate((_hardFloor - pos.y) * 3.0f) * 40.0f;

	// Mountains
	float frequency = 0.6 / 100.0;
	float amplitude = 1.0;
	float weight = 1.0f;
	float warp = snoise(pos * 0.009f);
	warp *= 4.0f;
	for (int j = 0; j < (int)8; j++)
	{
		float n = snoise((pos + offsetNoise) * frequency + _offsets[j] + _offset);
		float v = 1 - abs(n);
		v = v * v;
		v *= weight;
		weight = max(min(v * 10, 1), 0);
		noise += v * amplitude;
		amplitude *= 0.54;
		frequency *= 1.8;
	}

	//float mountain = _params.y * sin(PI * pos.y/ (float)_boundsSize.y);
	float finalVal = -(pos.y + 0) + noise * 20.0f +
		(sin(2.0f * PI * pos.z / _mountainous) + sin(2.0f * PI * pos.x / _mountainous)) * 30.0f;


	/*finalVal = noise * _noiseWeight;*/
	finalVal += saturate((-64.0f - pos.y) * 3.0f) * 40.0f;

	int index = indexFromCoord(id.x, id.y, id.z);
	//finalVal = -pos.y   + noise * _noiseWeight;
	_points[index] = float4(pos, finalVal);
}
